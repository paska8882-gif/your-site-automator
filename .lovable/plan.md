
## Що зараз ламається (діагностика по коду)
### 1) Перемикач в сайдбарі “ніфіга не працює” через керований стан
У `AppSidebar.tsx` компонент `MaintenanceToggleSidebar` рендерить `<Switch checked={enabled} ... />`, де `enabled` береться з `useMaintenanceMode()`:

- Коли ти клікаєш — робиться `UPDATE maintenance_mode ...` (і він реально проходить, в мережевих логах був `204`).
- Але **локально `enabled` не змінюється** (нема `setEnabled(newValue)` як у старому `AdminMaintenanceToggle`).
- Тобто свіч залишається у старому стані, доки не прийде realtime-івент або не відбудеться повторний fetch. Якщо realtime не приходить/затримується — виглядає як “не працює”.

### 2) Оверлей для користувачів залежить від того, чи maintenance стан взагалі оновився у клієнта
`App.tsx` показує `MaintenanceOverlay`, якщо:
- maintenance увімкнено
- і користувач **не адмін**
- і завершились лоадери

Якщо maintenance стан у клієнта не оновлюється (через пункт 1), то користувачі можуть не бачити блокування.

## Цільова поведінка (як ти описав)
- Перемикач має **надійно** вмикати/вимикати техрежим.
- При увімкненні: **всім користувачам**, крім адміна/суперадміна, **заборонити будь-які дії**, блюрнути інтерфейс і показати “ведуться технічні роботи, напишіть в підтримку”.
- Адміни/суперадміни повинні мати доступ, щоб все перевіряти/керувати.

## План виправлення
### A) Зробити перемикач “моментально” працюючим (не чекати realtime)
1) Оновити `useMaintenanceMode` так, щоб він повертав не тільки `{ maintenance, loading }`, а ще:
   - `setMaintenance` (або `refetchMaintenance`)
   - опціонально `error` (щоб бачити, якщо fetch впав)

2) У `MaintenanceToggleSidebar.handleToggle()`:
   - зробити **optimistic update**: одразу оновити локальний стан `maintenance.enabled = newValue`
   - якщо `UPDATE` повернув помилку — відкотити значення назад і показати toast
   - після успіху додатково викликати `refetchMaintenance()` (або invalidate через react-query, якщо переведемо hook на react-query)

Результат: свіч одразу переключається в UI і не “стрибає назад”.

### B) Зробити відображення оверлею максимально надійним
3) У `useMaintenanceMode` додати fallback, якщо рядок не знайдено:
   - встановлювати `maintenance` хоча б у дефолт `{ enabled:false, message:'...', support_link:'...' }`
   - щоб `maintenance?.enabled` не лишалося `undefined/null` через edge-case

4) У `App.tsx` залишити поточну логіку “крім адмінів”, але:
   - гарантувати, що під час loading ми нічого не “проморгуємо”
   - (опціонально) додати маленький “splash/loader” поки йде `isCheckingAccess`, щоб не було миготіння

### C) Переконатися, що realtime — бонус, а не залежність
5) Realtime підписка лишається, але **не є критичною** для UX:
   - Якщо realtime працює — інші вкладки/вікна підхоплять зміну миттєво
   - Якщо realtime не працює — все одно UI буде правильний завдяки optimistic update + refetch

### D) Перевірка end-to-end (обов’язково)
6) Тест-кейси:
   - Як super admin: клікнути свіч → він має одразу змінити стан і показати toast.
   - Відкрити сайт в інкогніто/іншому браузері (не адмін) → має з’явитися оверлей і блок дій.
   - Вимкнути техрежим → у не-адміна має зникнути оверлей і все знову працює.
   - Перевірити, що адміни/суперадміни не блокуються.

## Мінімальні файли, які потрібно буде змінити
- `src/hooks/useMaintenanceMode.ts` (додати refetch/сеттери/фолбек)
- `src/components/AppSidebar.tsx` (optimistic update + rollback + refetch після toggle)
- (опціонально) `src/App.tsx` (легкі правки для UX/надійності, якщо треба)

## Ризики / примітки
- Зараз у сайдбарі використовується `await import("@/integrations/supabase/client")` та `await import("sonner")` всередині handler’а. Це не причина бага, але ускладнює дебаг. Можна спростити на звичайні імпорти (рекомендовано).
- Якщо ти тестиш як адмін і очікуєш блокування — його не буде навмисно. Для перевірки блокування потрібен не-адмін або інкогніто без логіну.

