
# План виправлення проблем відображення історії та кнопки завантаження

## Виявлені проблеми

Після детального аналізу коду знайдено **3 основні проблеми**:

### Проблема 1: Кнопка "Завантажити" не активна на сторінці генератора

**Причина:** У компоненті `SingleHistoryItem` кнопка завантаження має перевірку `disabled={item.status !== "completed"}` (рядок 472), але сама кнопка відображається тільки в блоці `{item.status === "completed" && (...)}` (рядок 435). Це означає, що кнопка завантаження:
1. Не відображається взагалі для елементів зі статусом не "completed"
2. Коли елемент тільки що завершився і з'являється через realtime, `zip_data` може бути `null` (через обмеження розміру payload realtime)

**Проблема з realtime fetch:** У хуку `useGenerationHistory.ts` (рядок 355-364) при отриманні статусу "completed" робиться запит `select("*")`, але є race condition - якщо запит не встигне виконатися або поверне помилку, елемент оновиться без `zip_data`.

### Проблема 2: Деякі сайти не відображаються на сторінці "Історія"

**Причина 1 - Пагінація:** Хук завантажує тільки 10 елементів на сторінку (`PAGE_SIZE = 10`). Якщо користувач не натискає "Завантажити більше", він бачить тільки останні 10 записів.

**Причина 2 - Кеш конфлікт:** Є два окремих канали realtime:
- `generation_history_compact_{userId}` для генератора
- `generation_history_full_{userId}` для історії

Коли користувач на сторінці генератора завершує генерацію, оновлення йде в "compact" канал. Коли він переходить на "Історію", там свій "full" канал зі своїм станом, який може не мати нових даних через:
- `staleTime: 2 * 60 * 1000` - дані вважаються свіжими 2 хвилини
- `refetchOnMount: false` - при монтуванні компонента дані не перезавантажуються

**Причина 3 - LocalStorage кеш:** Кеш з `localStorage` завантажується при ініціалізації і може показувати застарілі дані (до 10 хвилин TTL).

### Проблема 3: Синхронізація між вкладками Generator та History

Компоненти використовують різні query keys та різні realtime канали, що створює неузгодженість даних.

---

## Рішення

### 1. Виправити lazy-load zip_data для кнопки завантаження

**Файл:** `src/components/GenerationHistory.tsx`

Функція `handleDownload` вже має lazy-load логіку (рядки 930-956), але потрібно:
- Додати індикатор завантаження на кнопку
- Покращити обробку помилок
- Переконатись, що кнопка завжди активна для `completed` статусу

### 2. Покращити realtime fetch для completed записів

**Файл:** `src/hooks/useGenerationHistory.ts`

- Додати retry логіку при помилці fetch
- Додати fallback якщо `zip_data` не отримано
- Зберегти `files_data` з повного запиту

### 3. Об'єднати кеш між compact та full режимами

**Файл:** `src/hooks/useGenerationHistory.ts`

- Використовувати спільний localStorage кеш
- При оновленні в compact режимі також оновлювати full кеш
- Зменшити staleTime та увімкнути `refetchOnMount` для full режиму

### 4. Автоматичне оновлення при переході на сторінку Історії

**Файл:** `src/pages/History.tsx`

- Додати примусове оновлення при монтуванні сторінки

---

## Технічні зміни

### `src/hooks/useGenerationHistory.ts`

```text
Зміни:
1. Рядок 42: PAGE_SIZE залишити 10, але...
2. Рядки 160-168: Змінити налаштування React Query:
   - staleTime: 30 * 1000 (30 секунд замість 2 хвилин)
   - refetchOnMount: true (для full mode)
3. Рядки 355-364: Додати retry при помилці fetch completed запису
4. Додати invalidation кешу full режиму при оновленні compact режиму
```

### `src/components/GenerationHistory.tsx`

```text
Зміни:
1. Рядки 464-476: Додати стан завантаження для кнопки Download
2. Рядки 930-956: Покращити handleDownload з loading state
3. Додати локальний стан для відстеження items що завантажуються
```

### `src/pages/History.tsx`

```text
Зміни:
1. Додати useEffect для примусового оновлення при монтуванні
```

---

## Очікуваний результат

1. **Кнопка завантаження** завжди активна для completed елементів, показує spinner при lazy-load
2. **Сторінка Історії** завжди показує актуальні дані при переході
3. **Синхронізація** між Generator та History працює коректно
4. **Realtime оновлення** надійно отримують повні дані з zip_data
